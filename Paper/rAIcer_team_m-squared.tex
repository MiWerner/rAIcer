\documentclass[11pt,final,journal,a4paper,towside,towcolumn]{IEEEtran}
\usepackage{cite}
\usepackage{graphicx}
\usepackage[utf8]{inputenc}
\usepackage[nolist]{acronym}
\usepackage{multirow}
\usepackage[table,xcdraw]{xcolor}

\begin{document}
\begin{acronym}
	\acro{NEAT}{NeuroEvolution of Augmenting Topologies}
	\acro{KI}{Künstliche Intelligenz}
\end{acronym}
	
\title{Abschlussbericht des Team $m^2$ zu dem \\Projektpraktikum Robotik und Automation:\\Künstliche Intelligenz}
\author{Marius Krusen und F. J. Michael Werner}
\maketitle

\begin{abstract}
Brauchen wir ein Abstrakt?
\end{abstract}

\section{Aufgabenstellung}
\IEEEPARstart{Z}{iel} des Projektpraktikums ist es, eine funktionsfähige  \ac{KI} für das Spiel rAIcer zu entwickeln. In dem Spiel können bis zu drei Spieler jeweils eine Figur über mehrere Runden auf einer Rundstrecke steuern. Die Figuren werden nur durch "Kraftimpulse" in den Richtungen oben, unten, links und rechts gesteuert. In einem abschließenden Turnier, soll die \ac{KI} in der Lage sein, auf bekannten sowie unbekannten Strecken gegen \acp{KI} anderer Teams anzutreten.

\section{Lösungsansatz}
Das Team $m^2$ verwendet für die Entwicklung der \ac{KI} den \ac{NEAT}-Algorithmus. Weiterhin wird das gegebene Problem darauf reduziert, dass die \ac{KI} eine Folge von Kontrollpunkten auf der Strecke abfahren muss. Für die Berechnung der Kontrollpunkte ist eine Streckenerkennung notwendig. Für die Eingabe, der durch den \ac{NEAT}-Algorithmus generierten neuronalen Netze, werden Merkmale berechnet, die unter anderem auf den Kontrollpunkten und der Position der Figur basieren. Die einzelnen Elemente des Lösungsansatzes werden nachfolgen im Detail vorgestellt.
\subsection{NEAT}
In der Neuroevolution werden Neuronale Netze mit Hilfe von genetischen Algorithmen generiert. In \cite{stanley:gecco02-efficient} stellen Stanley et al. \ac{NEAT} vor, der die Besonderheit hat, dass neben den Kantengewichten und Schwellenwerten, auch die Topologie des Netzes entwickelt wird.
Die zentralen Bausteine des Algorithmus sind:
\begin{itemize}
\item Darstellung eines Netzes als Genom	
\item Verwendung von Historie-Markern
\item Verwendung von Spezies
\item Minimierung der Dimensionalität
\end{itemize}
In jeder Generation liegt eine Menge von Genomen (Population) vor. Durch eine Fitnessfunktion, wird die Performance der einzelnen Genome bestimmt. Anschließend wird basierend auf den stärkeren Genomen mithilfe von Mutation und Kreuzungen neue Genome für die nächste Generation erzeugt. 
Für die Implementierung des Projektes wurde das Python-Package NEAT-Python \cite{python-neat} verwendet.
\subsubsection{Genetische Darstellung und Mutation}
Jedes Genom besteht aus einer Liste von Kanten-Genen. Diese referieren jeweils auf zwei Knoten-Gene, die deren Eingangs- und Ausgangsknoten darstellen. Des Weiteren enthalten die Kanten-Gene Informationen über ihre Kantengewichte, ein Aktivierungsbit und eine Innovationsnummer. 

Mutationen in \ac{NEAT} können die Kantengewichte und die Netzstruktur verändern. Die Mutation der Kantengewichte erfolgt über Entscheidung, basierend auf Wahrscheinlichkeiten, ob ein Knoten mutiert oder nicht. Die Mutation der Struktur kann auf zwei Weisen erfolgen. Zum einen kann ein einzelnen Kanten-Gen zwischen zwei bisher nicht verbunden Knoten-Genen hinzugefügt werden. Zum anderen kann ein Kanten-Gen durch zwei neue Kanten-Gene und ein neues Knoten-Gen ersetzt werden. Das alte Kanten-Gen wird dabei deaktiviert. Dadurch wird ein neuer Knoten in die Netzstruktur eingefügt.
\subsubsection{Historie-Marker und Kreuzungen}
Für die Kreuzung zweier Genome muss überprüft werden, welche Gene übereinstimmen. Dafür wird bei jedem neuen Gen eine globale Innovationsnummer erhöht und diesem Gen zugewiesen. Zwei Gene die den gleichen historischen Ursprung haben, also eine gleiche Innovationsnummer besitzen, repräsentieren die gleiche Struktur. Während der Kreuzung kann so leicht bestimmt werden, welche Gene in beiden Elterngenomen vorliegen und übernommen werden können. Gene die nicht in beiden Elterngenomen vorkommen, werden von dem Elterngenome mit dem höheren Fitnesswert vererbt.

\subsubsection{Spezies}
Durch das Hinzufügen einer neuen Struktur wird die Fitness anfänglich reduziert. Um eine neue Innovation zu schützen und ihr Zeit zur Optimierung zu geben, unterteilt \ac{NEAT} die Population in mehrere Spezies. Eine neue Innovation konkurriert erst mit den Genomen in der jeweiligen Spezies. Erst nach eine gewissen Zeit, wird eine Auslöschung durch einen Vergleich mit der restlichen Population möglich. Die Einteilung der Population in Spezies durch die Berechnung einer Distanz zwischen zwei Genomen $\delta$:
\begin{equation}
\delta=\frac{c_1E}{N} + \frac{c_2D}{N} + c_3\cdot \overline{W},
\end{equation}
mit der Anzahl überflüssiger Gene $E$, die Anzahl verschiedener Gene $D$ und der durchschnittlichen Differenz der Kantengewichte übereinstimmender Gene $\overline{W}$. Die Koeffizienten $c_1, c_2, c_3$ dienen zur Gewichtung der Faktoren und $N$, die Anzahl an Genen in dem größeren Genom, dient zu Normalisierung der Distanz. Jedes Genome wird mit einem zufällig ausgewählten Genome einer Spezies verglichen. Wird ein Schwellenwert $\delta_t$ unterschritten, wird das Genome der Spezies hinzugefügt.
\subsubsection{Minimierung der Dimensionalität}
\ac{NEAT} sieht vor, dass die anfängliche Population aus Netzen besteht, die keine verdeckten Knoten hat. Dadurch das Innovationen geschützt werden, können somit möglichst kleine Netze generiert werden, da nur neue Strukturen hinzugefügt werden, wenn sie im Sinne der Fitnessfunktion Verbesserungen einbringen.
Allerdings ermöglicht die \ac{NEAT}-Implementierung aus \cite{python-neat}, dass auch mit nicht leeren Neuronalen Netzen begonnen werden kann. Diese Funktion wurde auch in unseren Experimenten verwendet.

\subsection{Streckenerkennung und Kontrollpunkte}

\subsection{Merkmalsberechnung}

\section{Experimente und Ergebnisse}

Für die Entwicklung unserer \ac{KI} haben wir verschiedene Parameter unseres Aufbau ausprobiert. Diese Parameter werden nachfolgend vorgestellt. Anschließend werden die ausgewählte Versuche mit ihren Ergebnissen vorgestellt, die zu guten Ergebnissen geführt haben.
Für alle Experimente gilt, das zum Abfahren der geforderten Runden jeweils 3 Minuten Zeit gewesen sind. Die verwendeten \ac{NEAT}-Parameter sind in der Tabelle \ref{tab:NEAT} zu finden.
Zu dem wurden den initialen Population jeweils Kanten mit einer Wahrscheinlichkeit von 0,2 hinzugefügt.
\begin{table}
	\centering
	\begin{tabular}{|r|c|}
		\hline
		Parameter & Wert \\\hline\hline
		Populationsgröße & 45 \\\hline
		$P\left(\textrm{Knoten hinzufügen}\right)$ & 0,3 \\\hline
		$P\left(\textrm{Knoten entfernen}\right)$ & 0,1 \\\hline
		$P\left(\textrm{Schwellwert-Mutation}\right)$ & 0,8 \\\hline
		$P\left(\textrm{Kante hinzufügen}\right)$ & 0,75 \\\hline
		$P\left(\textrm{Kante entfernen}\right)$ & 0,3 \\\hline
		$P\left(\textrm{Kantengewicht-Mutation}\right)$ & 0,8 \\\hline
		Minimale Anzahl an Spezies & 2 \\\hline
	\end{tabular}
	\label{tab:NEAT}
	\caption{}{Übersicht der verwendeten \ac{NEAT}-Parameter.}
\end{table}
\subsection{Parameter}
\subsubsection{Anzahl Ausgangsknoten}
Wir haben die \ac{NEAT}-Algorithmus auf zwei verschiedene Ansätze angewendet, wie die Ausgangsneuronen für die Steuerung der Figur interpretiert werden können. 
In dem ersten Ansatz gibt es 4 Ausgangsneuronen, wobei je ein Neuron für eine der Richtungen oben, unten, links oder rechts steht. Da für die Aktivierungsfunktion der Neurone die Sigmoid-Funktion verwendet wurde, kann für ein Ausgangsneuron $o_r$ folgende Interpretation angewendet werden:
\begin{itemize}
	\item $o_r < 0.5:$ Taste $r$ nicht gedrückt
	\item $o_r \geq 0.5:$ Taste $r$ gedrückt.
\end{itemize}
Dabei stet $r$ für die vier verschiedenen möglichen Richtungen.

Für den zweiten Ansatz werden nur zwei Ausgangsneurone $o_h$ und $o_v$ benötigt. Für $o_h$ gilt dabei folgende Interpretation:
\begin{itemize}
	\item $o_h\leq 0.25$: Taste rechts gedrückt
	\item $0.25 < o_h <0.75$: weder Taste links noch Taste rechts gedrückt
	\item $o_h\geq 0.75$: Taste links gedrückt.
\end{itemize}
Für $o_v$ ist die Interpretation analog mit den Richtungen Unten und Oben.

\subsubsection{Strecke}
Die \acp{KI} wurden entweder ausschließlich auf der ersten Strecke des Spiels oder auf der dritten trainiert.

\subsubsection{Fitnessfunktion}
Wir haben zwei Arten von Fitnessfunktionen entwickelt. Beide basieren auf den Kontrollpunkten die bei der Streckenerkennung berechnet werden.
Die erste Fitnessfunktion $f_1$ wird über die Anzahl der abgefahrenen Kontrollpunkte definiert:
\begin{equation}
f_1 = \#KP,
\end{equation}
mit $\#KP$ als die Anzahl der abgefahrenen Kontrollpunkte. Die verwendeten Strecken 1 und 3 bestehen aus 48 beziehungsweise 52 Kontrollpunkten.
Die zweite Fitnessfunktion $f_2$ erweitert $f_1$ wie folgt:
\begin{equation}
f_2=\#KP + (180s-t) + (255 - s),
\end{equation}
mit $t$ als die benötigte Zeit in Sekunden und $s$ als der erlittene Schaden. Dabei sind 180s und 255 die jeweils maximal möglichen Werte.

\subsection{Experimente}



\begin{table}
	\centering
	\begin{tabular}{|c|c|c|c|c|c|c|}
		\hline
		& 0                                                   & 1                            & 2                            & 3                            & 4                            & Durchschnitt \\ \hline
		& \cellcolor[HTML]{C0C0C0} 3:17 & \cellcolor[HTML]{C0C0C0}3:24 & \cellcolor[HTML]{FFCCC9}3:29 & \cellcolor[HTML]{FFCCC9}2:47 & \cellcolor[HTML]{FFCCC9}3:05 & \cellcolor[HTML]{C0C0C0}-       \\ \cline{2-7} 
		\multirow{-2}{*}{0} & \cellcolor[HTML]{C0C0C0}255 & \cellcolor[HTML]{C0C0C0}255  & \cellcolor[HTML]{FFCCC9}255  & \cellcolor[HTML]{FFCCC9}255  & \cellcolor[HTML]{FFCCC9}255  & \cellcolor[HTML]{C0C0C0}255     \\ \hline
		& \cellcolor[HTML]{C0C0C0}2:02                        & \cellcolor[HTML]{C0C0C0}2:23 & \cellcolor[HTML]{FFCCC9}2:31 & \cellcolor[HTML]{FFCCC9}2:17 & \cellcolor[HTML]{FFCCC9}2:18 & \cellcolor[HTML]{C0C0C0}-       \\ \cline{2-7} 
		\multirow{-2}{*}{1} & \cellcolor[HTML]{C0C0C0}255                         & \cellcolor[HTML]{C0C0C0}255  & \cellcolor[HTML]{FFCCC9}255  & \cellcolor[HTML]{FFCCC9}255  & \cellcolor[HTML]{FFCCC9}255  & \cellcolor[HTML]{C0C0C0}255     \\ \hline
		& \cellcolor[HTML]{9AFF99}3:23                        & \cellcolor[HTML]{9AFF99}3:22 & \cellcolor[HTML]{C0C0C0}3:10 & \cellcolor[HTML]{FFCCC9}3:20 & \cellcolor[HTML]{FFCCC9}3:30 & \cellcolor[HTML]{C0C0C0}3:24    \\ \cline{2-7} 
		\multirow{-2}{*}{2} & \cellcolor[HTML]{9AFF99}160                         & \cellcolor[HTML]{9AFF99}76   & \cellcolor[HTML]{C0C0C0}56   & \cellcolor[HTML]{FFCCC9}146  & \cellcolor[HTML]{FFCCC9}162  & \cellcolor[HTML]{C0C0C0}136     \\ \hline
		& \cellcolor[HTML]{9AFF99}3:11                        & \cellcolor[HTML]{9AFF99}3:20 & \cellcolor[HTML]{9AFF99}3:19 & \cellcolor[HTML]{C0C0C0}3:13 & \cellcolor[HTML]{9AFF99}3:16 & \cellcolor[HTML]{9AFF99}3:17    \\ \cline{2-7} 
		\multirow{-2}{*}{3} & \cellcolor[HTML]{9AFF99}92                          & \cellcolor[HTML]{9AFF99}120  & \cellcolor[HTML]{9AFF99}129  & \cellcolor[HTML]{C0C0C0}70   & \cellcolor[HTML]{9AFF99}102  & \cellcolor[HTML]{9AFF99}110,75  \\ \hline
		& \cellcolor[HTML]{9AFF99}3:16                        & \cellcolor[HTML]{9AFF99}3:19 & \cellcolor[HTML]{9AFF99}3:18 & \cellcolor[HTML]{FFCCC9}3:19 & \cellcolor[HTML]{C0C0C0}3:17 & \cellcolor[HTML]{C0C0C0}3:18    \\ \cline{2-7} 
		\multirow{-2}{*}{4} & \cellcolor[HTML]{9AFF99}116                         & \cellcolor[HTML]{9AFF99}131  & \cellcolor[HTML]{9AFF99}144  & \cellcolor[HTML]{FFCCC9}174  & \cellcolor[HTML]{C0C0C0}117  & \cellcolor[HTML]{C0C0C0}141,25  \\ \hline 
	\end{tabular}
\caption{}{Vergleich der Performanz der durch die verschiedenen Experimente generierten Netze. Die Zelle in Zeile $n$ und Spalte $m$ enthält die gefahrene Zeit und den erhaltenen Schaden des Netzes $n$ aus dem direkten Vergleich zu Netz $m$. Die letzte Spalte enthält die Durchschnittswerte aus den Duell mit den anderen Netzen, sofern das Duell überlebt wurde. Mit rot, grün und grau, sind jeweils die Niederlagen, Siege oder Unentschieden gekennzeichnet.}
\end{table}
\section{Zusammenfassung}

\bibliography{Quellen}{}
\bibliographystyle{./IEEEtranBST2/IEEEtran}
\end{document}